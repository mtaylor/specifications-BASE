= The Expression Language

== Overview

This section describes the openEHR Expression Language. In the various contexts where openEHR expressions are used, the syntax provides a foundation for concrete  syntaxes supporting specific value-referencing mechanisms, as well as other types of rules, operands etc. The key features of the language are: variable declarations, assignments and expressions. Most of the semantics are in the expression part, which is based on first-order predicate logic with the addition of arithmetic and relational operators to enable the use of numeric elements. Expressions may contain constants, variable references, value references and functions.

== Syntax style

The syntax style used here is generally so-called 'snake_case' rather than so-called 'CamelCase', in common with other openEHR specifications, but either may be used in real applications.

== Typing and Literals

The Expression language is fully typed. The type system is the same as that used in other openEHR components, and supports the same set of basic types, namely:

* primitive types;
* container types:
** `List<T>`, i.e. an ordered list of elements of primitive type T;
** `Set<T>`, i.e. a set of elements of primitive type T;
** `Hash<K:Ordered,V>`, i.e. a Hash table or dictionary;
* an interval type:
** `Interval<T: Ordered>` where T is any ordered primitive type.

These types are described below.

=== Primitive Types

The primitive types are shown below, along with typical literal values, which are expressed in the {openehr_odin}#_primitive_types[ODIN syntax].

[cols="1,2, 3",options="header"]
|=================================================================
|Name                   |Literal value                          |Description

| `Boolean`             |`True`, `False`                        |Boolean value
| `Integer`             |`10`, `-4`, `1024`                     |Integer value
| `Real`                |`10.0`, `0.345`                        |Real value
| `Date`                |`2004-08-12`                           |ISO8601-format date
| `Date_time`           |`2004-08-12T12:00:59+0100`             |ISO8601-format date/time
| `Time`                |`12:00:59`                             |ISO8601-format time
| `Duration`            |`P39W`                                 |ISO8601-format duration
| `String`              |`"this is a string"`                   |String
| `Uri`                 |`https://en.wikipedia.org/wiki/Everest`|Uri in <<uri_syntax,RFC3986 format>>
| `Terminology_code`    |`[snomed_ct::389086002]` +
                         `[snomed_ct::389086002\|Hypoxia\|]`      |Terminology code reference
|=================================================================

Automatic type promotion from `Integer` to `Real` applies to all integer and real values and expressions, in the same fashion as most programming languages.

[.tbd]
TBD: do we need `Integer64` and `Real64`?

=== Container Types

The same container types as defined in the {openehr_foundation_types}#_structure_types[BASE Foundation Types specification] are supported in EL, as follows.

[cols="1,2, 3",options="header"]
|=================================================================
|Name                   |Literal value                  |Description

| `List<T>`             |`[val, val, ...]`              |Linear list of items of any primitive type, allowing order and repeated membership'
| `Set<T>`              |`{val, val, ...}`              |Set of items of any primitive type; no order, unique membership;
| `Hash<K:Ordered, V>`  |`< +
                              ["key1"] = <val1> +
                              ["key2"] = <val2> +
                              ... +
                              ["keyN"] = <valN> +
                         >`                             |Indexed linear container; +
                                                         concretely, a table of values of any type V, keyed by values of any Ordered descendant K, typically String or Integer
|=================================================================


The above types each have an assumed interface consisting of functions and procedures that apply to all members of the container, consistent with the semantics of the container. These include the following.

----
    has (v: T): Boolean
            -- True container contains v

    for_all (test(v: T): Boolean): Boolean
            -- True if for every v in container, test (v) is True

    there_exists (test(v: T): Boolean): Boolean
            -- True if there is any v in container for which test (v) is True
            
    do_all (proc(v: T))
            -- execute proc(v) for every v in interval

    do_if (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in interval for which test(v) is True

    do_while (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in interval until test (v) returns False

    do_until (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in interval until test (v) returns True
----

Any such method may be accessed in the usual way, using dot notation, i.e. as shown below for the method `some()`.

----
    $heart_rate_samples: List<Real>
    Atrial_fibrillation_threshold: Real = 100.0
    
    if $heart_rate_samples.some (
        (v:Real): Boolean
            do
                Result := v > Atrial_fibrillation_threshold 
            end
        )
    then
        --
    end
----

=== Interval Type

The same `Interval` type as defined in the {openehr_foundation_types}#_interval[BASE Foundation Types specification] is supported in EL, as follows. Literal interval values take the same form as in {openehr_odin}#_intervals_of_ordered_primitive_types[ODIN].

[cols="1,2, 3",options="header"]
|=================================================================
|Name                   |Literal value                  |Description

| `Interval<T>`         |                               |Interval of any ordered primitive
|                       |`\|N..M\|`                     |the two-sided interval N >= x \<= M
|                       |`\|>N..M\|`                    |the two-sided interval N > x \<= M
|                       |`\|N..<M\|`                    |the two-sided interval N >= x < M
|                       |`\|<N\|`                       |the one-sided interval x < N
|                       |`\|>N\|`                       |the one-sided interval x > N
|                       |`\|\<=N\|`                     |the one-sided interval x \<= N
|                       |`\|>=N\|`                      |the one-sided interval x >= N
|                       |`\|N +/-M\|`                   |the two-sided interval of N ±M
|                       |`\|N±M\|`                      |the two-sided interval of N ±M
|=================================================================

Automatic type promotion from `Interval<Integer>` to `Interval<Real>` applies to all integer and real values and expressions, in the same fashion as most programming languages.

Various methods are assumed for `Interval<T>`, as follows.

----
    has (v: T): Boolean
            -- True if for Interval contains v

    overlaps (other: like Current): Boolean
            -- True if this Interval overlaps other
            
    contains (other: like Current): Boolean
            -- True if this Interval contains other
----

== Basic Structures

=== Declarations

Variables may be declared within a statement set, consisting of a name of the form `var_name` for a local variable, and `$var_name` for a bound variable, and a type. Multiple variables may be declared on the same line. The following shows various declarations:

--------
    date_of_birth: Date                     -- local variable
    age_in_years: Integer                   -- local variable
    
    $weight, $height, $bmi: Real            -- 3 bound variables
    
    $heart_rate_samples: List<Real>         -- container type
--------

Variables are referenced within assignments and expressions using the same syntax, i.e. `var_name` and `$var_name`.

=== Constants

Constants are defined via the use of the equality operator `=` in a declaration, as follows.

--------
    Mph_to_kmh_factor: Real = 1.6
    Pounds_to_kg: Real = 0.4536
--------

The result of the declaration is to defined the symbols `Mph_to_kmh_factor` and `Pounds_to_kg` as immutable constants.

=== Assignment

An assignment to a writable variable is expressed using the `:=` operator. An assignment may be made in a declaration in the same way as in many programming languages. The right hand side of an assignment is any value-returning expression. Typical assignments are illustrated below.

--------
    speed_kmh: Real                             -- declaration
    speed_mph: Real := 35.0                     -- assignment in a declaration (not a constant)
        
    speed_kmh := speed_mph * Mph_to_kmh_factor  -- assignment
--------

== Bound Variables, Evaluation and Validity

Variables that are bound to entities in the data context function differently from local variables, since their availability is predicated on the existence of the relevant entities. For example, the variable `$body_weight` may be bound to a call that retrieves a patient heart rate from the EHR, via an appropriate API call. There is no guarantee that the value is available, so `$body_weight` may therefore be undefined in a sense not applicable to local variables. In a programming language, if a variable is not explicitly set, it has either the default value of the type (e.g. `0` for `Integer`) or a random value of the correct type. This behaviour is appropriate for local variables, but for bound variables that cannot be evaluated because the external entity does not exist, we want something like an exception to occur.

The approach used for EL is to allow bound variables to be used freely, as for local variables, but if a bound variable cannot be evaluated from the data context, an `'undefined value'` exception should be generated, indicating which variable could not be evaluated. To impose more control, the predicate `defined ()` can be used within a `if()` or `check()` block to ensure that one or more variables can be populated before proceeding with logic that depends on them, as follows:

----
    if defined ($heart_rate) and defined ($blood_pressure) then
        -- statements mentioning $heart_rate and $blood_pressure
    end

    check defined ($heart_rate) and defined ($blood_pressure) then  -- generates exception is False
        -- statements mentioning $heart_rate and $blood_pressure
    end
----

Another difference between bound and local variables is when they are evaluated. In the execution of a larger EL text containing multiple mentions of a bound variable `v`, is `v` read from the data context only once, at the first mention, or is it evaluated new each time, or on some other basis? The approach used in EL is to allow the evaluation basis to be stated in the context binding section of an EL text using the `currency` attribute.

To assert that a certain part of a larger data structure exists, the following construct can be used.

--------
    check $is_smoker implies defined ($smoking_details) end
--------

[[language-expressions]]
== Expressions

Expressions constitute the main part of the Expressions language, and consist of a familiar typed, operator-based syntax common to many programming languages and logics. Formally, an expression is any of the following entities:

* _terminal entities_:
** _symbolic variables_;
** _constants_;
** _literals_: values are of any primitive type, and are expressed in the {openehr_odin}[ODIN syntax]. Examples are shown above under <<Typing>>;
* _non-terminal entities_:
** _operators_: arithmetic operators, relational operators, boolean operators, quantification operators;
** _functions_: built-in functions and user-defined functions.

The terminal entity types have already been described above. This section describes operators and functions.

=== Functions

All functions are considered to have a formal type signature of the form:

----
    <T_arg1, T_arg2, ....>: T_result
    
e.g.

    : Date                          -- signature of a 0-order function like current_date
    <Real, Real>: Real              -- signature of a 2nd-order function like '*' for the domain R
    <Integer, Integer>: Integer     -- signature of a 2nd-order function like 'add' for the domain I
----

Note that 0-order functions do not require parentheses when called.

All functions that take `Real` argument will take `Integer` arguments and automatically promote them to `Real` in the usual fashion.

==== Built-in Functions

Functions are considered leaf entities in the Expression language, and can be of a built-in type or external (user-defined) type. A simple example is:

----
    $date_of_birth: Date                   -- bound to data context
    age: Duration
    
    age := current_date - $date_of_birth   
----

This uses the built-in 0-order function `current_date` to compute a person's age in the standard way. The typing is based on the operator `-` (subtract) being defined on the type `Date` as the following:

----
    class Date
        infix '-' alias subtract (Date): Duration
----

The built-in functions are listed below.

[cols="1,1,1,2",options="header"]
|=================================================================
|Name               |Textual Rendering 	|Signature          |Meaning

4+^h|Degree 0 functions (no arguments)

|current_date       |current_date       |:Date              |Current date
|current_time       |current_time       |:Time              |Current time
|current_date_time  |current_date_time  |:Date_time         |Curent date time

4+^h|Degree N functions (N arguments)

|sum                |`sum (x, y, ....)` |<Real, ...>: Real  |Equivalent to x + y + ...
|mean               |`mean (x, y, ...)` |<Real, ...>: Real  |The mean (average) value of x, y, ...
|max                |`max (x, y, ...)`  |<Real, ...>: Real  |The maximum value among x, y, ...
|min                |`min (x, y, ...)`  |<Real, ...>: Real  |The minimum value among x, y, ...

|=================================================================

[[language-operators]]
=== Operators

Expressions can include arithmetic, relational and boolean operators, plus the existential and universal quantifiers. The full operator set is shown below, along with textual and symbolic renderings. The latter are just standard Unicode symbols. Expression parsers should ideally support these symbols as operator equivalents in addition to the textual form, since it allows expressions to be expressed in a more compact and less language-independent way.

[cols="1,1,1,3",options="header"]
|=================================================================
|Identifier   |Textual +
               Rendering 	  |Symbolic +
                               Rendering  |Meaning
                               
4+^h|Arithmetic Operators - Numeric result; descending precendence order

|exp          | ^             |≥          |Expontentiation
|times        | *             |*          |Multiplication
|divide       | /             |/          |Division
|mod          | %             |%          |Modulo (whole number) division
|plus         | +             |+          |Addition
|minus        | -             |-          |Subtraction

4+^h|Relational Operators - Boolean result; equal precedence

|eq           | =             |=          |Equality relation between numerics
|ne           | !=            |≠          |Inequality relation between numerics
|lt           | <             |<          |Less than relation between numerics
|le           | \<=           |≤          |Less than or equal relation between numerics
|gt           | >             |>          |Greater than relation between numerics
|ge           | >=            |≥          |Greater than or equal relation between numerics

4+^h|Logical Operators - Boolean result; descending precendence order

|not          |not, ~ 		|∼  		 |Negation, "not p"
|and          |and 			|∧ 			|Logical conjunction, "p and q"
|or           |or 			|∨ 			|Logical disjunction, "p or q"
|xor          |xor 			|⊻ 			 |Exclusive or, "only one of p or q"
|implies      |implies 		|⇒ 			 |Material implication, "p implies q", or "if p then q"

|=================================================================

Operator semantics that require further explanation are described below.

==== Logical Negation

All Boolean operators take Boolean operands and generate a Boolean result. The `not` operator can be applied as a prefix operator to all operators returning a Boolean result as well as a parenthesised Boolean expression.

==== Precedence and Parentheses

The precedence of operators follows the order shown in the operator tables above. To change precedence, parentheses can be used in the fashion typical of most programming languages, as shown below.

--------
    at_risk := $weight > 120 and ($is_smoker or $is_hypertensive)
--------

== Container Operators

The two standard quantification operators from predicate logic `there exists` (∃ operator) and `for all` (∀ operator) are defined in EL for the container types found in the {openehr_foundation_types}[openEHR Foundation Types^].

The textual syntax of `there exists` is as follows:

----
    there_exists v in container_var | <Boolean expression mentioning v> 
----

Here, the `|` symbol is usually read in English as 'such that'. The symbolic equivalent may also be used:

----
    ∃ v : container_var | <Boolean expression mentioning v>
----

The above may also be expressed in EL as its functional equivalent:

[source,kotlin]
----
    list_of_reals: List<Real>
    
    |
    | an expression that will return true if list_of_reals
    | contains a value greater than 140.0
    |
    list_of_reals.there_exists (
        agent (v: Real): Boolean {
            v > 140.0
        }
    )
----

The `for_all` operator has similar textual syntax:

----
    for_all v in container_var | <Boolean expression mentioning v>
----

Here, the `|` symbol is normally read in English as as 'it holds that'. The symbolic equivalent may also be used:

----
    ∀ v : container_var | <Boolean expression mentioning v>
----

The above may also be expressed in EL as its functional equivalent:

[source,kotlin]
----
    list_of_reals: List<Real>
    
    |
    | an expression that will return true if list_of_reals
    | consists of values all greater than 140.0
    |
    list_of_reals.for_all (
        agent (v: Real): Boolean {
            v > 140.0
        }
    )
----

